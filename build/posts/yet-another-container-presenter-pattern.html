<!doctype html>
<html><head><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/zenburn.min.css"/><link rel="stylesheet" type="text/css" href="../css/post.css"/><link rel="icon" type="image/png" href="../public/favicon.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Yet Another Container/Presenter Pattern</title></head><body><header><a href="../" class="back">Â« Back</a><h1>Yet Another Container/Presenter Pattern</h1></header><time>November 08, 2016</time><article><p><em>These ideas are not just for&nbsp;React, but for&nbsp;simplicity, I&nbsp;will be using React to&nbsp;demonstrate.</em></p>
<p>I&nbsp;am not going to&nbsp;go over what Smart/Dumb components are, Dan Abramov already did a&nbsp;great job <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.nrqfzj2dj">here</a>.</p>
<p>These are awesome ideas! And&nbsp;I would like to&nbsp;expand upon it.</p>
<p>Before I&nbsp;start, let me be clear. This pattern I&nbsp;will be explaining is <strong><abbr>NOT</abbr></strong> for&nbsp;every little component.</p>
<p>Without future adoâ€¦</p>
<p>Introduce another level of&nbsp;complexity ðŸ˜„!</p>
<p>Yes, it sounds ridiculous, but here is the&nbsp;reason: <strong>Data which is easy to&nbsp;store and&nbsp;update is not always structured in&nbsp;an efficient manner to&nbsp;pass down through components or&nbsp;for the&nbsp;components to&nbsp;use and&nbsp;reduce that data.</strong></p>
<p>My&nbsp;proposition is to&nbsp;use a&nbsp;<strong>View Container</strong> in&nbsp;between the&nbsp;Data Store and&nbsp;the Presenter.</p>
<p><img src="https://docs.google.com/drawings/d/1SLtlXyZzw6CukM2CigBJOyMpq9Yny57p9-L7sIonKA0/pub?w=629&amp;h=195" alt="Pattern Flow"></p>
<p>By&nbsp;splitting up the&nbsp;way we manage the&nbsp;data and&nbsp;the way we manage the&nbsp;view state we can use better data structures to&nbsp;store, update, and&nbsp;obtain the&nbsp;necessary data to&nbsp;present.</p>
<p>Here are some examples of&nbsp;the same application, but handling data, reducing, and&nbsp;rendering differently.</p>
<h3>First is our monolith. Do everything in&nbsp;one component.</h3>
<iframe width="100%" height="300" src="http://jsfiddle.net/fojjyLkk/1/embedded/js,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<h3>Second is using the&nbsp;plain Container/Presenter pattern.</h3>
<iframe width="100%" height="300" src="http://jsfiddle.net/cnmLyqx7/1/embedded/js,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<h3>Third example shows Data Store/View Container/Presenter pattern.</h3>
<iframe width="100%" height="300" src="http://jsfiddle.net/d6nc2u9t/embedded/js,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
<p>The&nbsp;state and&nbsp;action handler in&nbsp;the last example can be extracted out as&nbsp;a Redux Store/Reducer, which would clean up this example even more.</p>
<p>I&nbsp;hope my&nbsp;explanation showed how we can improve the&nbsp;separation of&nbsp;concerns and&nbsp;logic in&nbsp;our applications.</p>
<h2>Go refactor something!!</h2>
</article></body></html>