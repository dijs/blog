<!doctype html>
<html><head><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/default.min.css"/><link rel="stylesheet" type="text/css" href="../css/post.css"/><link rel="icon" type="image/png" href="../public/favicon.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mutation Testing in Javascript</title></head><body><header><a href="../" class="back">« Back</a><h1>Mutation Testing in Javascript</h1></header><time>March 01, 2015</time><article><h3>Intro</h3>
<p>Mutation testing is hard… But totally worth it!</p>
<p>I&nbsp;recently learned about the&nbsp;concept from a&nbsp;colleague. For&nbsp;those who might not know what it is:</p>
<p>Testing by&nbsp;mutation calculates the&nbsp;durability of&nbsp;your unit tests against mutated versions of&nbsp;your source code. These mutant versions are designed to&nbsp;be the&nbsp;result of&nbsp;common programming errors. Since there are many different types of&nbsp;errors, this means that normally a&nbsp;large number of&nbsp;mutants are created and&nbsp;tested. These mutants would be extremely difficult to&nbsp;create by&nbsp;hand, so mutants are generally automatically generated from changing the&nbsp;source code using common <em>error</em> patterns.</p>
<p>Error pattern examples may include switching conditional, logical, and&nbsp;arithmetic operators. Possibly even changing the&nbsp;value of&nbsp;literals within the&nbsp;code. These are just a&nbsp;few ideas, and&nbsp;I am hoping one day we can have a&nbsp;more <em>standardized</em> set of&nbsp;patterns to&nbsp;use.</p>
<h3>How it works</h3>
<p>A&nbsp;(hopefully obvious) perquisite to&nbsp;mutation testing is that your unit tests need to&nbsp;<strong>pass</strong> against your original source code. Also, the&nbsp;faster your unit tests are, the&nbsp;easier mutation testing will be.</p>
<p>So, step by&nbsp;step:</p>
<ol>
<li>A&nbsp;baseline unit test is run against your original source code</li>
<li>Mutated versions of&nbsp;your code (<strong>mutants</strong>) are generated by&nbsp;changing the&nbsp;code slightly</li>
<li>Each mutant is ran against the&nbsp;same unit tests</li>
<li>If a&nbsp;mutant passes the&nbsp;test suite, it is considered <strong>killed</strong></li>
<li>Your <strong>score</strong> is calculated by&nbsp;how many mutants were killed against how many were created</li>
</ol>
<p>The&nbsp;goal is to&nbsp;try to&nbsp;kill all the&nbsp;mutants.</p>
<h3>By&nbsp;example…</h3>
<p>Here we have a&nbsp;very simple Javascript module:</p>
<pre><code class="language-javascript lang-javascript"><span class="hljs-comment">//Bank Account Module</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">var</span> balance = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">this</span>.getBalance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
		<span class="hljs-keyword">return</span> balance;
	};
	<span class="hljs-keyword">this</span>.deposit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">amount</span>) </span>{
		balance += amount;
	};
	<span class="hljs-keyword">this</span>.withdraw = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">amount</span>) </span>{
		<span class="hljs-keyword">if</span> (balance &gt;= amount) {
			balance -= amount;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
	};
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};
</code></pre>
<p>Easy mutation could be to&nbsp;change the&nbsp;balance literal to&nbsp;initialize to&nbsp;-1.</p>
<p>If our unit tests started each check with a&nbsp;clean Account instance and&nbsp;assumed that the&nbsp;balance should be 0, our tests would fail.</p>
<pre><code class="language-javascript lang-lisp">//Unit Test <span class="hljs-list">(<span class="hljs-keyword">Wrong</span>)</span>
it<span class="hljs-list">(<span class="hljs-quoted">'should</span> deposit', function<span class="hljs-list">()</span> {
	account.deposit<span class="hljs-list">(<span class="hljs-number">50</span>)</span><span class="hljs-comment">;</span>
	account.getBalance<span class="hljs-list">()</span>.should.equal<span class="hljs-list">(<span class="hljs-number">50</span>)</span><span class="hljs-comment">;</span>
})</span><span class="hljs-comment">;</span>
</code></pre>
<p>The&nbsp;corrected unit test might look something like this:</p>
<pre><code class="language-javascript lang-lisp">//Unit Test <span class="hljs-list">(<span class="hljs-keyword">Corrected</span>)</span>
it<span class="hljs-list">(<span class="hljs-quoted">'should</span> deposit', function<span class="hljs-list">()</span> {
	var initial = account.getBalance<span class="hljs-list">()</span><span class="hljs-comment">;</span>
	account.deposit<span class="hljs-list">(<span class="hljs-number">50</span>)</span><span class="hljs-comment">;</span>
	account.getBalance<span class="hljs-list">()</span>.should.equal<span class="hljs-list">(<span class="hljs-keyword">initial</span> + <span class="hljs-number">50</span>)</span><span class="hljs-comment">;</span>
})</span><span class="hljs-comment">;</span>
</code></pre>
<p>This is <strong>one</strong> example where mutation testing could help.</p>
<h3>So I&nbsp;created something</h3>
<p>In&nbsp;order to&nbsp;better understand and&nbsp;learn about mutation testing, I&nbsp;wanted to&nbsp;write my&nbsp;own Javascript mutation tester. I&nbsp;found one project for&nbsp;mutation testing in&nbsp;Javascript, and&nbsp;although I&nbsp;am normally a&nbsp;fan of&nbsp;"don't <nobr>re-invent</nobr> the&nbsp;wheel". In&nbsp;this case, the&nbsp;tool was only usable for&nbsp;<em>grunt</em> built projects. I&nbsp;wanted to&nbsp;create a&nbsp;more general use tool which was (build system) agnostic.</p>
<p>Big hurdle I&nbsp;hit with writing this was actually "node-specifc" issues. While mutating source code, loading and&nbsp;running tests, I&nbsp;kept getting the&nbsp;same results. After hours of&nbsp;beating my&nbsp;head against the&nbsp;wall, I&nbsp;tried renaming the&nbsp;files before loading them in. Sure enough, it worked. So in&nbsp;doing this project I&nbsp;learned a&nbsp;bit more about how the&nbsp;node.js <strong>require</strong> method works and&nbsp;how it caches files.</p>
<p><a href="https://github.com/dijs/profx">Here</a> is the&nbsp;project.</p>
</article></body></html>